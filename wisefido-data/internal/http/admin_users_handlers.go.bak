package httpapi

import (
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/lib/pq"
)

// ============================================
// 已废弃：旧的 AdminUsers Handler
// ============================================
// 注意：此文件中的 AdminUsers 函数已被新的 UserHandler 替代
// 新的实现：
//   - Service 层：internal/service/user_service.go
//   - Handler 层：internal/http/user_handler.go
//   - 路由注册：router.RegisterUsersRoutes()
//
// 保留此文件仅用于参考，实际已不再使用。
// getRoleLevel 和 canCreateRole 函数已在 user_service.go 中重新实现。
// ============================================

// getRoleLevel 返回角色的层级（数字越小，权限越高）
// Level 1: SystemAdmin, SystemOperator (系统级)
// Level 2: Admin (租户管理员)
// Level 3: Manager, IT (业务管理层)
// Level 4: Nurse, Caregiver (操作层)
// Level 5: Resident, Family (用户角色)
// 注意：此函数已废弃，新实现请使用 service.getRoleLevel
func getRoleLevel(role string) int {
	switch strings.ToLower(role) {
	case "systemadmin", "systemoperator":
		return 1
	case "admin":
		return 2
	case "manager", "it":
		return 3
	case "nurse", "caregiver":
		return 4
	case "resident", "family":
		return 5
	default:
		return 999 // 未知角色，最严格
	}
}

// canCreateRole 检查当前用户是否可以创建指定角色
// 规则：可以创建同级或下级角色（方案A）
// 注意：此函数已废弃，新实现请使用 service.canCreateRole
func canCreateRole(currentRole, targetRole string) bool {
	// SystemAdmin 和 SystemOperator 只能由 SystemAdmin 创建（已有单独检查）
	if targetRole == "SystemAdmin" || targetRole == "SystemOperator" {
		return false // 这个检查在调用前已经单独处理
	}

	currentLevel := getRoleLevel(currentRole)
	targetLevel := getRoleLevel(targetRole)

	// 方案A：允许创建同级或下级角色
	return targetLevel >= currentLevel
}

// AdminUsers 已废弃：旧的用户管理 Handler
// 新的实现请使用 UserHandler（internal/http/user_handler.go）
// 此函数已从路由注册中移除，不再使用
func (s *StubHandler) AdminUsers(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path == "/admin/api/v1/users" {
		switch r.Method {
		case http.MethodGet:
			if s != nil && s.DB != nil {
				tenantID, ok := s.tenantIDFromReq(w, r)
				if !ok {
					fmt.Printf("[AdminUsers] Failed to get tenant_id from request\n")
					return
				}
				fmt.Printf("[AdminUsers] Got tenant_id: %s\n", tenantID)
				search := strings.TrimSpace(r.URL.Query().Get("search"))

				// Get current user info for permission-based filtering
				userID := r.Header.Get("X-User-Id")
				var userRole, userBranchTag sql.NullString

				if userID != "" {
					// Get user role and branch_tag
					err := s.DB.QueryRowContext(r.Context(),
						`SELECT role, branch_tag FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, userID,
					).Scan(&userRole, &userBranchTag)
					if err != nil && err != sql.ErrNoRows {
						fmt.Printf("[AdminUsers] Failed to get user info: %v\n", err)
					}
				}

				// Check role_permissions for users resource
				var permCheck *PermissionCheck
				if userRole.Valid && userRole.String != "" {
					var err error
					permCheck, err = GetResourcePermission(s.DB, r.Context(), userRole.String, "users", "R")
					if err != nil {
						fmt.Printf("[AdminUsers] Failed to check role permissions: %v\n", err)
						// Default to most restrictive permissions for safety
						permCheck = &PermissionCheck{AssignedOnly: true, BranchOnly: true}
					}
				} else {
					// If no role found, default to most restrictive permissions for safety
					permCheck = &PermissionCheck{AssignedOnly: true, BranchOnly: true}
				}

				args := []any{tenantID}
				q := `SELECT user_id::text, tenant_id::text, user_account, nickname, email, phone, role, status,
				             COALESCE(alarm_levels, ARRAY[]::varchar[]) as alarm_levels,
				             COALESCE(alarm_channels, ARRAY[]::varchar[]) as alarm_channels,
				             alarm_scope, branch_tag, last_login_at,
				             COALESCE(tags, '[]'::jsonb) as tags,
				             COALESCE(preferences, '{}'::jsonb) as preferences
				      FROM users
				      WHERE tenant_id = $1`

				// Apply permission-based filtering
				if permCheck.AssignedOnly && userID != "" {
					// Caregiver/Nurse: can only view self
					args = append(args, userID)
					q += fmt.Sprintf(` AND user_id::text = $%d`, len(args))
				} else if permCheck.BranchOnly {
					// Manager: can only view users in the same branch
					if !userBranchTag.Valid || userBranchTag.String == "" {
						// User branch_tag is NULL: can only view users with branch_tag IS NULL OR '-'
						q += ` AND (users.branch_tag IS NULL OR users.branch_tag = '-')`
					} else {
						// User branch_tag has value: can only view users with matching branch_tag
						args = append(args, userBranchTag.String)
						q += fmt.Sprintf(` AND users.branch_tag = $%d`, len(args))
					}
				}
				// Admin/IT: no additional filtering (can view all users)

				if search != "" {
					args = append(args, "%"+search+"%")
					q += fmt.Sprintf(` AND (user_account ILIKE $%d OR COALESCE(nickname,'') ILIKE $%d OR COALESCE(email,'') ILIKE $%d OR COALESCE(phone,'') ILIKE $%d)`, len(args), len(args), len(args), len(args))
				}
				q += ` ORDER BY user_account ASC`
				fmt.Printf("[AdminUsers] Executing query: %s with args: %v\n", q, args)
				rows, err := s.DB.QueryContext(r.Context(), q, args...)
				if err != nil {
					// Log the actual error for debugging
					fmt.Printf("[AdminUsers] SQL query error: %v, query: %s, args: %v\n", err, q, args)
					writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("failed to list users: %v", err)))
					return
				}
				fmt.Printf("[AdminUsers] Query executed successfully, starting to scan rows\n")
				defer rows.Close()
				out := []any{}
				rowCount := 0
				for rows.Next() {
					rowCount++
					fmt.Printf("[AdminUsers] Scanning row %d\n", rowCount)
					var userID, tid, userAccount, role, status string
					var nickname, email, phone sql.NullString
					var alarmLevels []string
					var alarmChannels []string
					var alarmScope, branchTag sql.NullString
					var lastLoginAt sql.NullTime
					var tagsRaw, prefRaw []byte
					if err := rows.Scan(
						&userID, &tid, &userAccount, &nickname, &email, &phone, &role, &status,
						pq.Array(&alarmLevels), pq.Array(&alarmChannels), &alarmScope, &branchTag, &lastLoginAt, &tagsRaw, &prefRaw,
					); err != nil {
						// Log the actual error for debugging
						fmt.Printf("[AdminUsers] Row scan error at row %d: %v\n", rowCount, err)
						writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("failed to list users: %v", err)))
						return
					}
					fmt.Printf("[AdminUsers] Successfully scanned row %d: user_account=%s\n", rowCount, userAccount)
					var tags []string
					if len(tagsRaw) > 0 {
						_ = json.Unmarshal(tagsRaw, &tags)
					}
					var prefs any
					if len(prefRaw) > 0 {
						_ = json.Unmarshal(prefRaw, &prefs)
					}
					item := map[string]any{
						"user_id":      userID,
						"tenant_id":    tid,
						"user_account": userAccount,
						"role":         role,
						"status":       status,
					}
					if nickname.Valid {
						item["nickname"] = nickname.String
					}
					if email.Valid {
						item["email"] = email.String
					}
					if phone.Valid {
						item["phone"] = phone.String
					}
					if alarmLevels != nil && len(alarmLevels) > 0 {
						item["alarm_levels"] = alarmLevels
					}
					if alarmChannels != nil && len(alarmChannels) > 0 {
						item["alarm_channels"] = alarmChannels
					}
					if alarmScope.Valid {
						item["alarm_scope"] = alarmScope.String
					}
					if branchTag.Valid {
						item["branch_tag"] = branchTag.String
					}
					if lastLoginAt.Valid {
						item["last_login_at"] = lastLoginAt.Time.Format(time.RFC3339)
					}
					if tags != nil {
						item["tags"] = tags
					}
					if prefs != nil {
						item["preferences"] = prefs
					}
					out = append(out, item)
				}
				// Check for errors from iterating over rows
				if err := rows.Err(); err != nil {
					fmt.Printf("[AdminUsers] Rows iteration error: %v\n", err)
					writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("failed to list users: %v", err)))
					return
				}
				fmt.Printf("[AdminUsers] Successfully listed %d users\n", len(out))
				writeJSON(w, http.StatusOK, Ok(map[string]any{"items": out, "total": len(out)}))
				return
			}
			writeJSON(w, http.StatusOK, Fail("database not available"))
		case http.MethodPost:
			if s != nil && s.DB != nil {
				tenantID, ok := s.tenantIDFromReq(w, r)
				if !ok {
					return
				}
				var payload map[string]any
				if err := readBodyJSON(r, 1<<20, &payload); err != nil {
					writeJSON(w, http.StatusOK, Fail("invalid body"))
					return
				}
				userAccount, _ := payload["user_account"].(string)
				role, _ := payload["role"].(string)
				password, _ := payload["password"].(string)
				if strings.TrimSpace(userAccount) == "" || strings.TrimSpace(role) == "" || password == "" {
					writeJSON(w, http.StatusOK, Fail("user_account, role, password are required"))
					return
				}
				role = strings.TrimSpace(role)
				
				// Get current user's real role from database (security: don't trust header)
				currentUserID := r.Header.Get("X-User-Id")
				var currentUserRole string
				if currentUserID != "" {
					err := s.DB.QueryRowContext(r.Context(),
						`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, currentUserID,
					).Scan(&currentUserRole)
					if err != nil {
						if err == sql.ErrNoRows {
							writeJSON(w, http.StatusOK, Fail("current user not found"))
						} else {
							writeJSON(w, http.StatusOK, Fail("failed to get current user role"))
						}
						return
					}
				} else {
					writeJSON(w, http.StatusOK, Fail("user ID is required"))
					return
				}
				
				// Security: system roles can only be assigned by SystemAdmin within System tenant.
				if role == "SystemAdmin" || role == "SystemOperator" {
					if tenantID != SystemTenantID() || !strings.EqualFold(currentUserRole, "SystemAdmin") {
						writeJSON(w, http.StatusOK, Fail("not allowed to assign system role"))
						return
					}
				} else {
					// Check role hierarchy: can only create same level or lower level roles
					if currentUserRole != "" && !canCreateRole(currentUserRole, role) {
						writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to create %s role (current role: %s)", role, currentUserRole)))
						return
					}
				}
				userAccount = strings.ToLower(strings.TrimSpace(userAccount))
				ah, _ := hex.DecodeString(HashAccount(userAccount))
				// Password hash should only depend on password itself (independent of account/phone/email)
				aph, _ := hex.DecodeString(HashPassword(password))
				if len(ah) == 0 || len(aph) == 0 {
					writeJSON(w, http.StatusOK, Fail("failed to hash credentials"))
					return
				}
				nickname, _ := payload["nickname"].(string)
				email, _ := payload["email"].(string)
				phone, _ := payload["phone"].(string)
				// Calculate email_hash and phone_hash for login (if email/phone provided)
				var emailHashArg, phoneHashArg any = nil, nil
				if email != "" {
					eh, _ := hex.DecodeString(HashAccount(email))
					if len(eh) > 0 {
						emailHashArg = eh
					}
				}
				if phone != "" {
					ph, _ := hex.DecodeString(HashAccount(phone))
					if len(ph) > 0 {
						phoneHashArg = ph
					}
				}
				status := "active"
				if st, ok := payload["status"].(string); ok && st != "" {
					status = st
				}

				// Parse alarm configuration fields
				var alarmLevels pq.StringArray
				if levels, ok := payload["alarm_levels"].([]any); ok && len(levels) > 0 {
					alarmLevels = make([]string, 0, len(levels))
					for _, l := range levels {
						if s, ok := l.(string); ok && s != "" {
							alarmLevels = append(alarmLevels, s)
						}
					}
				}
				var alarmChannels pq.StringArray
				if channels, ok := payload["alarm_channels"].([]any); ok && len(channels) > 0 {
					alarmChannels = make([]string, 0, len(channels))
					for _, c := range channels {
						if s, ok := c.(string); ok && s != "" {
							alarmChannels = append(alarmChannels, s)
						}
					}
				}
				// Parse alarm_scope: set default based on role if not provided
				var alarmScope sql.NullString
				if scope, ok := payload["alarm_scope"].(string); ok && scope != "" {
					alarmScope = sql.NullString{String: scope, Valid: true}
				} else {
					// Set default alarm_scope based on role
					roleLower := strings.ToLower(role)
					if roleLower == "caregiver" || roleLower == "nurse" {
						alarmScope = sql.NullString{String: "ASSIGNED_ONLY", Valid: true}
					} else if roleLower == "manager" {
						alarmScope = sql.NullString{String: "BRANCH", Valid: true}
					}
					// Other roles: leave as NULL (no default)
				}

				// Parse tags (JSONB): store as JSON array of strings
				var tagsJSON []byte
				if tags, ok := payload["tags"].([]any); ok && len(tags) > 0 {
					tagsStr := make([]string, 0, len(tags))
					for _, t := range tags {
						if s, ok := t.(string); ok && s != "" {
							tagsStr = append(tagsStr, s)
						}
					}
					if len(tagsStr) > 0 {
						if b, err := json.Marshal(tagsStr); err == nil {
							tagsJSON = b
						}
					}
				}
				var tagsArg any = nil
				if len(tagsJSON) > 0 {
					tagsArg = tagsJSON
				}

				// Check email/phone uniqueness before insert
				if err := checkEmailUniqueness(s.DB, r, tenantID, email, ""); err != nil {
					writeJSON(w, http.StatusOK, Fail(err.Error()))
					return
				}
				if err := checkPhoneUniqueness(s.DB, r, tenantID, phone, ""); err != nil {
					writeJSON(w, http.StatusOK, Fail(err.Error()))
					return
				}

				var userID string
				err := s.DB.QueryRowContext(
					r.Context(),
					`INSERT INTO users (tenant_id, user_account, user_account_hash, password_hash, nickname, email, phone, email_hash, phone_hash, role, status, alarm_levels, alarm_channels, alarm_scope, tags)
					 VALUES ($1,$2,$3,$4,NULLIF($5,''),NULLIF($6,''),NULLIF($7,''),$8,$9,$10,$11,$12,$13,$14,$15)
					 RETURNING user_id::text`,
					tenantID, userAccount, ah, aph, nickname, email, phone,
					emailHashArg, phoneHashArg,
					role, status, pq.Array(alarmLevels), pq.Array(alarmChannels), alarmScope, tagsArg,
				).Scan(&userID)
				if err != nil {
					// Check for unique constraint violation
					if msg := checkUniqueConstraintError(err, "email or phone"); msg != "" {
						writeJSON(w, http.StatusOK, Fail(msg))
						return
					}
					writeJSON(w, http.StatusOK, Fail("failed to create user"))
					return
				}
				// Optional: allow dev login via AuthStore as well (keeps current auth flow).
				if s.AuthStore != nil {
					_ = s.AuthStore.UpsertUser(tenantID, userAccount, role, password)
				}
				writeJSON(w, http.StatusOK, Ok(map[string]any{"user_id": userID}))
				return
			}
			writeJSON(w, http.StatusOK, Fail("database not available"))
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
		return
	}
	if strings.HasPrefix(r.URL.Path, "/admin/api/v1/users/") {
		path := strings.TrimPrefix(r.URL.Path, "/admin/api/v1/users/")
		if strings.HasSuffix(path, "/reset-password") {
			if r.Method != http.MethodPost {
				w.WriteHeader(http.StatusMethodNotAllowed)
				return
			}
			if s != nil && s.DB != nil {
				tenantID, ok := s.tenantIDFromReq(w, r)
				if !ok {
					return
				}
				userID := strings.TrimSuffix(path, "/reset-password")
				if userID == "" || strings.Contains(userID, "/") {
					w.WriteHeader(http.StatusNotFound)
					return
				}

				// Permission check: can reset own password or have permission to reset other user's password
				currentUserID := r.Header.Get("X-User-Id")
				if currentUserID == "" {
					writeJSON(w, http.StatusOK, Fail("user ID is required"))
					return
				}
				
				// Get current user's real role from database (security: don't trust header)
				var currentUserRole string
				err := s.DB.QueryRowContext(r.Context(),
					`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, currentUserID,
				).Scan(&currentUserRole)
				if err != nil {
					if err == sql.ErrNoRows {
						writeJSON(w, http.StatusOK, Fail("current user not found"))
					} else {
						writeJSON(w, http.StatusOK, Fail("failed to get current user role"))
					}
					return
				}
				
				isResettingSelf := currentUserID == userID

				// If resetting other user's password, check role hierarchy
				if !isResettingSelf {
					// Get target user's role
					var targetUserRole string
					err := s.DB.QueryRowContext(r.Context(),
						`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, userID,
					).Scan(&targetUserRole)
					if err != nil {
						if err == sql.ErrNoRows {
							writeJSON(w, http.StatusOK, Fail("user not found"))
						} else {
							writeJSON(w, http.StatusOK, Fail("failed to get user info"))
						}
						return
					}

					// Check if current user can reset target user's password (role hierarchy check)
					if currentUserRole != "" && !canCreateRole(currentUserRole, targetUserRole) {
						writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to reset password for %s role user (current role: %s)", targetUserRole, currentUserRole)))
						return
					}
				}

				var payload map[string]any
				if err := readBodyJSON(r, 1<<20, &payload); err != nil {
					writeJSON(w, http.StatusOK, Fail("invalid body"))
					return
				}
				newPassword, _ := payload["new_password"].(string)
				if newPassword == "" {
					writeJSON(w, http.StatusOK, Fail("new_password is required"))
					return
				}

				// Look up user_account for hashing
				var userAccount, role string
				err = s.DB.QueryRowContext(
					r.Context(),
					`SELECT user_account, role
					   FROM users
					  WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, userID,
				).Scan(&userAccount, &role)
				if err != nil {
					writeJSON(w, http.StatusOK, Fail("user not found"))
					return
				}

				// Hash password: sha256(password) - only depends on password itself (independent of account/phone/email)
				aph, _ := hex.DecodeString(HashPassword(newPassword))
				if len(aph) == 0 {
					writeJSON(w, http.StatusOK, Fail("failed to hash password"))
					return
				}
				_, err = s.DB.ExecContext(
					r.Context(),
					`UPDATE users SET password_hash = $3
					  WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, userID, aph,
				)
				if err != nil {
					writeJSON(w, http.StatusOK, Fail("failed to reset password"))
					return
				}
				// Optional: keep AuthStore in sync for dev/stub flows.
				if s.AuthStore != nil {
					_ = s.AuthStore.UpsertUser(tenantID, userAccount, role, newPassword)
				}
				writeJSON(w, http.StatusOK, Ok(map[string]any{"success": true, "message": "ok"}))
				return
			}
			writeJSON(w, http.StatusOK, Fail("database not available"))
			return
		}
		if strings.HasSuffix(path, "/reset-pin") {
			if r.Method != http.MethodPost {
				w.WriteHeader(http.StatusMethodNotAllowed)
				return
			}
			if s != nil && s.DB != nil {
				tenantID, ok := s.tenantIDFromReq(w, r)
				if !ok {
					return
				}
				userID := strings.TrimSuffix(path, "/reset-pin")
				if userID == "" || strings.Contains(userID, "/") {
					w.WriteHeader(http.StatusNotFound)
					return
				}

				// Permission check: can reset own PIN or have permission to reset other user's PIN
				// Note: Currently Caregiver/Nurse don't have UI to reset PIN, but backend allows it for consistency
				currentUserID := r.Header.Get("X-User-Id")
				if currentUserID == "" {
					writeJSON(w, http.StatusOK, Fail("user ID is required"))
					return
				}
				
				// Get current user's real role from database (security: don't trust header)
				var currentUserRole string
				err := s.DB.QueryRowContext(r.Context(),
					`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, currentUserID,
				).Scan(&currentUserRole)
				if err != nil {
					if err == sql.ErrNoRows {
						writeJSON(w, http.StatusOK, Fail("current user not found"))
					} else {
						writeJSON(w, http.StatusOK, Fail("failed to get current user role"))
					}
					return
				}
				
				isResettingSelf := currentUserID == userID

				// If resetting other user's PIN, check role hierarchy
				if !isResettingSelf {
					// Get target user's role
					var targetUserRole string
					err = s.DB.QueryRowContext(r.Context(),
						`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, userID,
					).Scan(&targetUserRole)
					if err != nil {
						if err == sql.ErrNoRows {
							writeJSON(w, http.StatusOK, Fail("user not found"))
						} else {
							writeJSON(w, http.StatusOK, Fail("failed to get user info"))
						}
						return
					}

					// Check if current user can reset target user's PIN (role hierarchy check)
					if currentUserRole != "" && !canCreateRole(currentUserRole, targetUserRole) {
						writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to reset PIN for %s role user (current role: %s)", targetUserRole, currentUserRole)))
						return
					}
				}

				var payload map[string]any
				if err := readBodyJSON(r, 1<<20, &payload); err != nil {
					writeJSON(w, http.StatusOK, Fail("invalid body"))
					return
				}
				newPin, _ := payload["new_pin"].(string)
				if newPin == "" {
					writeJSON(w, http.StatusOK, Fail("new_pin is required"))
					return
				}
				// Validate PIN: must be exactly 4 digits
				if len(newPin) != 4 {
					writeJSON(w, http.StatusOK, Fail("PIN must be exactly 4 digits"))
					return
				}
				for _, c := range newPin {
					if c < '0' || c > '9' {
						writeJSON(w, http.StatusOK, Fail("PIN must contain only digits"))
						return
					}
				}

				// Hash PIN: sha256(pin) - only depends on PIN itself
				pinHash, _ := hex.DecodeString(HashPassword(newPin))
				if len(pinHash) == 0 {
					writeJSON(w, http.StatusOK, Fail("failed to hash PIN"))
					return
				}
				_, err = s.DB.ExecContext(
					r.Context(),
					`UPDATE users SET pin_hash = $3
					  WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, userID, pinHash,
				)
				if err != nil {
					writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("failed to reset PIN: %v", err)))
					return
				}
				writeJSON(w, http.StatusOK, Ok(map[string]any{"success": true}))
				return
			}
			writeJSON(w, http.StatusOK, Fail("database not available"))
			return
		}
		id := path
		if strings.Contains(id, "/") {
			w.WriteHeader(http.StatusNotFound)
			return
		}
		switch r.Method {
		case http.MethodPut:
			if s != nil && s.DB != nil {
				tenantID, ok := s.tenantIDFromReq(w, r)
				if !ok {
					return
				}
				var payload map[string]any
				if err := readBodyJSON(r, 1<<20, &payload); err != nil {
					writeJSON(w, http.StatusOK, Fail("invalid body"))
					return
				}
				// Soft delete via {_delete:true}
				if del, ok := payload["_delete"].(bool); ok && del {
					// Check permission: can only delete users with same level or lower level roles
					currentUserID := r.Header.Get("X-User-Id")
					if currentUserID == "" {
						writeJSON(w, http.StatusOK, Fail("user ID is required"))
						return
					}
					
					// Get current user's real role from database (security: don't trust header)
					var currentUserRole string
					err := s.DB.QueryRowContext(r.Context(),
						`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, currentUserID,
					).Scan(&currentUserRole)
					if err != nil {
						if err == sql.ErrNoRows {
							writeJSON(w, http.StatusOK, Fail("current user not found"))
						} else {
							writeJSON(w, http.StatusOK, Fail("failed to get current user role"))
						}
						return
					}

					// Get target user's role
					var targetUserRole string
					err = s.DB.QueryRowContext(r.Context(),
						`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, id,
					).Scan(&targetUserRole)
					if err != nil {
						if err == sql.ErrNoRows {
							writeJSON(w, http.StatusOK, Fail("user not found"))
						} else {
							writeJSON(w, http.StatusOK, Fail("failed to get user info"))
						}
						return
					}

					// Check if current user can delete target user (role hierarchy check)
					if currentUserRole != "" && !canCreateRole(currentUserRole, targetUserRole) {
						writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to delete %s role (current role: %s)", targetUserRole, currentUserRole)))
						return
					}

					_, err = s.DB.ExecContext(
						r.Context(),
						`UPDATE users SET status = 'left' WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, id,
					)
					if err != nil {
						writeJSON(w, http.StatusOK, Fail("failed to delete user"))
						return
					}
					writeJSON(w, http.StatusOK, Ok(map[string]any{"success": true}))
					return
				}

				// Update editable fields
				nickname, _ := payload["nickname"].(string)
				// Handle email: can be string or empty string (to clear to NULL)
				// Frontend sends email_hash (always) and email (only if save is checked)
				var email string
				var emailProvided bool
				var emailIsNull bool
				var emailHashProvided bool
				var emailHashArg any = nil
				// Get email_hash from frontend (calculated on frontend, always sent if email has value)
				if emailHashHex, exists := payload["email_hash"]; exists {
					emailHashProvided = true
					if str, ok := emailHashHex.(string); ok {
						if str != "" {
							eh, _ := hex.DecodeString(str)
							if len(eh) > 0 {
								emailHashArg = eh
							}
						} else {
							emailHashArg = nil // Empty string means null
						}
					} else if emailHashHex == nil {
						emailHashArg = nil // null means null
					}
				}
				// Get email: if null, means delete; if string, means save
				if emailVal, ok := payload["email"]; ok {
					emailProvided = true
					if emailVal == nil {
						emailIsNull = true // Explicitly null: delete email
					} else if str, ok := emailVal.(string); ok {
						email = str
					}
				}
				// Handle phone: same logic as email
				var phone string
				var phoneProvided bool
				var phoneIsNull bool
				var phoneHashProvided bool
				var phoneHashArg any = nil
				if phoneHashHex, exists := payload["phone_hash"]; exists {
					phoneHashProvided = true
					if str, ok := phoneHashHex.(string); ok {
						if str != "" {
							ph, _ := hex.DecodeString(str)
							if len(ph) > 0 {
								phoneHashArg = ph
							}
						} else {
							phoneHashArg = nil
						}
					} else if phoneHashHex == nil {
						phoneHashArg = nil
					}
				}
				if phoneVal, ok := payload["phone"]; ok {
					phoneProvided = true
					if phoneVal == nil {
						phoneIsNull = true
					} else if str, ok := phoneVal.(string); ok {
						phone = str
					}
				}
				role, _ := payload["role"].(string)
				status, _ := payload["status"].(string)

				// Get current user's real role from database (security: don't trust header)
				currentUserID := r.Header.Get("X-User-Id")
				var currentUserRole string
				if currentUserID != "" {
					err := s.DB.QueryRowContext(r.Context(),
						`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, currentUserID,
					).Scan(&currentUserRole)
					if err != nil {
						if err == sql.ErrNoRows {
							writeJSON(w, http.StatusOK, Fail("current user not found"))
						} else {
							writeJSON(w, http.StatusOK, Fail("failed to get current user role"))
						}
						return
					}
				} else {
					writeJSON(w, http.StatusOK, Fail("user ID is required"))
					return
				}

				// Check if updating self or other user
				isUpdatingSelf := currentUserID != "" && currentUserID == id

				// Determine what fields are being updated (excluding password which is handled separately)
				updatingRole := role != ""
				updatingStatus := status != ""
				updatingOtherFields := nickname != "" || emailProvided || phoneProvided ||
					payload["alarm_levels"] != nil || payload["alarm_channels"] != nil ||
					payload["alarm_scope"] != nil || payload["tags"] != nil || payload["branch_tag"] != nil

				// Permission check:
				// 1. If updating self and only updating password/email/phone, no restriction
				// 2. If updating other user or updating role/status/other fields, need permission check
				if !isUpdatingSelf || updatingRole || updatingStatus || updatingOtherFields {
					// Get target user's current role for comparison
					var targetUserRole string
					err := s.DB.QueryRowContext(r.Context(),
						`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
						tenantID, id,
					).Scan(&targetUserRole)
					if err != nil {
						if err == sql.ErrNoRows {
							writeJSON(w, http.StatusOK, Fail("user not found"))
						} else {
							writeJSON(w, http.StatusOK, Fail("failed to get user info"))
						}
						return
					}

					// If updating role, check if can assign new role
					if updatingRole {
						// Security: system roles can only be assigned by SystemAdmin within System tenant.
						if role == "SystemAdmin" || role == "SystemOperator" {
							if tenantID != SystemTenantID() || !strings.EqualFold(currentUserRole, "SystemAdmin") {
								writeJSON(w, http.StatusOK, Fail("not allowed to assign system role"))
								return
							}
						} else {
							// Check role hierarchy: can only assign same level or lower level roles
							if currentUserRole != "" && !canCreateRole(currentUserRole, role) {
								writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to assign %s role (current role: %s)", role, currentUserRole)))
								return
							}
						}
					}

					// If updating other user or updating status/other fields, check if can manage target user
					if !isUpdatingSelf || updatingStatus || updatingOtherFields {
						// Check if current user can manage target user (role hierarchy check)
						if currentUserRole != "" && !canCreateRole(currentUserRole, targetUserRole) {
							writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to update %s role user (current role: %s)", targetUserRole, currentUserRole)))
							return
						}
					}
				}

				// Only allow known status changes; otherwise keep unchanged.
				if status != "" && status != "active" && status != "disabled" && status != "left" {
					writeJSON(w, http.StatusOK, Fail("invalid status"))
					return
				}

				// Parse alarm configuration fields (only update if provided)
				var alarmLevels pq.StringArray
				if levels, ok := payload["alarm_levels"].([]any); ok {
					alarmLevels = make([]string, 0, len(levels))
					for _, l := range levels {
						if s, ok := l.(string); ok && s != "" {
							alarmLevels = append(alarmLevels, s)
						}
					}
				}
				var alarmChannels pq.StringArray
				if channels, ok := payload["alarm_channels"].([]any); ok {
					alarmChannels = make([]string, 0, len(channels))
					for _, c := range channels {
						if s, ok := c.(string); ok && s != "" {
							alarmChannels = append(alarmChannels, s)
						}
					}
				}
				var alarmScope sql.NullString
				if scope, ok := payload["alarm_scope"].(string); ok {
					if scope != "" {
						alarmScope = sql.NullString{String: scope, Valid: true}
					}
				}

				// Parse tags (JSONB): only update if provided
				var tagsJSON []byte
				var tagsProvided bool
				if tags, ok := payload["tags"].([]any); ok {
					tagsProvided = true
					tagsStr := make([]string, 0, len(tags))
					for _, t := range tags {
						if s, ok := t.(string); ok && s != "" {
							tagsStr = append(tagsStr, s)
						}
					}
					// Always marshal (even empty array) to allow clearing tags
					if b, err := json.Marshal(tagsStr); err == nil {
						tagsJSON = b
					}
				}

				// Build dynamic UPDATE query based on what fields are provided
				updates := []string{}
				args := []any{tenantID, id}
				argIdx := 3

				if nickname != "" {
					updates = append(updates, fmt.Sprintf("nickname = $%d", argIdx))
					args = append(args, nickname)
					argIdx++
				}
				// Update email: if email_hash is provided, update hash (for login)
				// If email is also provided and not null, update both email and hash (save is checked)
				// If email is null but hash is provided, delete email but keep hash (save is unchecked)
				if emailHashProvided {
					if emailProvided && emailIsNull {
						// email is explicitly null: delete email but keep hash (save is unchecked)
						updates = append(updates, fmt.Sprintf("email = $%d, email_hash = $%d", argIdx, argIdx+1))
						args = append(args, nil, emailHashArg)
						argIdx += 2
					} else if emailProvided && email != "" {
						// Save both email and hash (save is checked)
						updates = append(updates, fmt.Sprintf("email = $%d, email_hash = $%d", argIdx, argIdx+1))
						args = append(args, email, emailHashArg)
						argIdx += 2
					} else {
						// email not provided but hash is: only update hash (legacy case, shouldn't happen with new frontend)
						updates = append(updates, fmt.Sprintf("email_hash = $%d", argIdx))
						args = append(args, emailHashArg)
						argIdx++
					}
				} else if emailProvided {
					// Legacy: if only email is provided (no hash), calculate hash
					if emailIsNull {
						updates = append(updates, fmt.Sprintf("email = $%d, email_hash = $%d", argIdx, argIdx+1))
						args = append(args, nil, nil)
						argIdx += 2
					} else if email != "" {
						emailHash, _ := hex.DecodeString(HashAccount(email))
						updates = append(updates, fmt.Sprintf("email = $%d, email_hash = $%d", argIdx, argIdx+1))
						args = append(args, email, emailHash)
						argIdx += 2
					}
				}
				// Update phone: if phone_hash is provided, update hash (for login)
				// If phone is also provided and not null, update both phone and hash (save is checked)
				// If phone is null but hash is provided, delete phone but keep hash (save is unchecked)
				if phoneHashProvided {
					if phoneProvided && phoneIsNull {
						// phone is explicitly null: delete phone but keep hash (save is unchecked)
						updates = append(updates, fmt.Sprintf("phone = $%d, phone_hash = $%d", argIdx, argIdx+1))
						args = append(args, nil, phoneHashArg)
						argIdx += 2
					} else if phoneProvided && phone != "" {
						// Save both phone and hash (save is checked)
						updates = append(updates, fmt.Sprintf("phone = $%d, phone_hash = $%d", argIdx, argIdx+1))
						args = append(args, phone, phoneHashArg)
						argIdx += 2
					} else {
						// phone not provided but hash is: only update hash (legacy case, shouldn't happen with new frontend)
						updates = append(updates, fmt.Sprintf("phone_hash = $%d", argIdx))
						args = append(args, phoneHashArg)
						argIdx++
					}
				} else if phoneProvided {
					// Legacy: if only phone is provided (no hash), calculate hash
					if phoneIsNull {
						updates = append(updates, fmt.Sprintf("phone = $%d, phone_hash = $%d", argIdx, argIdx+1))
						args = append(args, nil, nil)
						argIdx += 2
					} else if phone != "" {
						phoneHash, _ := hex.DecodeString(HashAccount(phone))
						updates = append(updates, fmt.Sprintf("phone = $%d, phone_hash = $%d", argIdx, argIdx+1))
						args = append(args, phone, phoneHash)
						argIdx += 2
					}
				}
				if role != "" {
					updates = append(updates, fmt.Sprintf("role = $%d", argIdx))
					args = append(args, role)
					argIdx++
				}
				if status != "" {
					updates = append(updates, fmt.Sprintf("status = $%d", argIdx))
					args = append(args, status)
					argIdx++
				}
				if _, ok := payload["alarm_levels"]; ok {
					updates = append(updates, fmt.Sprintf("alarm_levels = $%d", argIdx))
					args = append(args, pq.Array(alarmLevels))
					argIdx++
				}
				if _, ok := payload["alarm_channels"]; ok {
					updates = append(updates, fmt.Sprintf("alarm_channels = $%d", argIdx))
					args = append(args, pq.Array(alarmChannels))
					argIdx++
				}
				if _, ok := payload["alarm_scope"]; ok {
					updates = append(updates, fmt.Sprintf("alarm_scope = $%d", argIdx))
					args = append(args, alarmScope)
					argIdx++
				}
				if tagsProvided {
					updates = append(updates, fmt.Sprintf("tags = $%d", argIdx))
					args = append(args, tagsJSON) // tagsJSON is always set when tagsProvided is true
					argIdx++
				}
				if branchTag, ok := payload["branch_tag"].(string); ok {
					updates = append(updates, fmt.Sprintf("branch_tag = $%d", argIdx))
					if branchTag != "" {
						args = append(args, branchTag)
					} else {
						args = append(args, nil) // Set to NULL if empty string
					}
					argIdx++
				}

				if len(updates) == 0 {
					writeJSON(w, http.StatusOK, Ok(map[string]any{"success": true}))
					return
				}

				// Check email/phone uniqueness before update (if being updated and not null)
				if emailProvided && !emailIsNull && email != "" {
					if err := checkEmailUniqueness(s.DB, r, tenantID, email, id); err != nil {
						writeJSON(w, http.StatusOK, Fail(err.Error()))
						return
					}
				}
				if phoneProvided && !phoneIsNull && phone != "" {
					if err := checkPhoneUniqueness(s.DB, r, tenantID, phone, id); err != nil {
						writeJSON(w, http.StatusOK, Fail(err.Error()))
						return
					}
				}

				query := fmt.Sprintf(`UPDATE users SET %s WHERE tenant_id = $1 AND user_id::text = $2`, strings.Join(updates, ", "))
				_, err := s.DB.ExecContext(r.Context(), query, args...)
				if err != nil {
					// Check for unique constraint violation
					if msg := checkUniqueConstraintError(err, "email or phone"); msg != "" {
						writeJSON(w, http.StatusOK, Fail(msg))
						return
					}
					writeJSON(w, http.StatusOK, Fail("failed to update user"))
					return
				}
				writeJSON(w, http.StatusOK, Ok(map[string]any{"success": true}))
				return
			}
			writeJSON(w, http.StatusOK, Fail("database not available"))
			return
		case http.MethodDelete:
			// Soft delete: keep row for audit, mark as left.
			if s != nil && s.DB != nil {
				tenantID, ok := s.tenantIDFromReq(w, r)
				if !ok {
					return
				}

				// Check permission: can only delete users with same level or lower level roles
				currentUserID := r.Header.Get("X-User-Id")
				if currentUserID == "" {
					writeJSON(w, http.StatusOK, Fail("user ID is required"))
					return
				}
				
				// Get current user's real role from database (security: don't trust header)
				var currentUserRole string
				err := s.DB.QueryRowContext(r.Context(),
					`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, currentUserID,
				).Scan(&currentUserRole)
				if err != nil {
					if err == sql.ErrNoRows {
						writeJSON(w, http.StatusOK, Fail("current user not found"))
					} else {
						writeJSON(w, http.StatusOK, Fail("failed to get current user role"))
					}
					return
				}

				// Get target user's role
				var targetUserRole string
				err = s.DB.QueryRowContext(r.Context(),
					`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, id,
				).Scan(&targetUserRole)
				if err != nil {
					if err == sql.ErrNoRows {
						writeJSON(w, http.StatusOK, Fail("user not found"))
					} else {
						writeJSON(w, http.StatusOK, Fail("failed to get user info"))
					}
					return
				}

				// Check if current user can delete target user (role hierarchy check)
				if currentUserRole != "" && !canCreateRole(currentUserRole, targetUserRole) {
					writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to delete %s role (current role: %s)", targetUserRole, currentUserRole)))
					return
				}

				_, err = s.DB.ExecContext(
					r.Context(),
					`UPDATE users SET status = 'left' WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, id,
				)
				if err != nil {
					writeJSON(w, http.StatusOK, Fail("failed to delete user"))
					return
				}
				writeJSON(w, http.StatusOK, Ok(map[string]any{"success": true}))
				return
			}
			writeJSON(w, http.StatusOK, Fail("database not available"))
			return
		case http.MethodGet:
			if s != nil && s.DB != nil {
				tenantID, ok := s.tenantIDFromReq(w, r)
				if !ok {
					return
				}
				// Get current user info for permission check
				currentUserID := r.Header.Get("X-User-Id")
				if currentUserID == "" {
					writeJSON(w, http.StatusOK, Fail("user ID is required"))
					return
				}

				// Get current user's real role from database (security: don't trust header)
				var currentUserRole string
				err := s.DB.QueryRowContext(r.Context(),
					`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, currentUserID,
				).Scan(&currentUserRole)
				if err != nil {
					if err == sql.ErrNoRows {
						writeJSON(w, http.StatusOK, Fail("current user not found"))
					} else {
						writeJSON(w, http.StatusOK, Fail("failed to get current user role"))
					}
					return
				}

				// Get target user's role
				var targetUserRole string
				err = s.DB.QueryRowContext(r.Context(),
					`SELECT role FROM users WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, id,
				).Scan(&targetUserRole)
				if err != nil {
					if err == sql.ErrNoRows {
						writeJSON(w, http.StatusOK, Fail("user not found"))
					} else {
						writeJSON(w, http.StatusOK, Fail("failed to get user info"))
					}
					return
				}

				// Check if current user can view target user (role hierarchy check)
				isViewingSelf := currentUserID == id
				if !isViewingSelf {
					if currentUserRole != "" && !canCreateRole(currentUserRole, targetUserRole) {
						writeJSON(w, http.StatusOK, Fail(fmt.Sprintf("not allowed to view %s role user (current role: %s)", targetUserRole, currentUserRole)))
						return
					}
				}

				var userID, tid, userAccount, role, status string
				var nickname, email, phone sql.NullString
				var alarmLevels []string
				var alarmChannels []string
				var alarmScope, branchTag sql.NullString
				var lastLoginAt sql.NullTime
				var tagsRaw, prefRaw []byte
				err = s.DB.QueryRowContext(
					r.Context(),
					`SELECT user_id::text, tenant_id::text, user_account, nickname, email, phone, role, status,
					             COALESCE(alarm_levels, ARRAY[]::varchar[]) as alarm_levels,
					             COALESCE(alarm_channels, ARRAY[]::varchar[]) as alarm_channels,
					             alarm_scope, branch_tag, last_login_at,
					             COALESCE(tags, '[]'::jsonb) as tags,
					             COALESCE(preferences, '{}'::jsonb) as preferences
					      FROM users
					      WHERE tenant_id = $1 AND user_id::text = $2`,
					tenantID, id,
				).Scan(
					&userID, &tid, &userAccount, &nickname, &email, &phone, &role, &status,
					pq.Array(&alarmLevels), pq.Array(&alarmChannels), &alarmScope, &branchTag, &lastLoginAt, &tagsRaw, &prefRaw,
				)
				if err != nil {
					if err == sql.ErrNoRows {
						writeJSON(w, http.StatusOK, Fail("user not found"))
					} else {
						writeJSON(w, http.StatusOK, Fail("failed to get user"))
					}
					return
				}
				var tags []string
				if len(tagsRaw) > 0 {
					_ = json.Unmarshal(tagsRaw, &tags)
				}
				var prefs any
				if len(prefRaw) > 0 {
					_ = json.Unmarshal(prefRaw, &prefs)
				}
				item := map[string]any{
					"user_id":      userID,
					"tenant_id":    tid,
					"user_account": userAccount,
					"role":         role,
					"status":       status,
				}
				if nickname.Valid {
					item["nickname"] = nickname.String
				}
				if email.Valid {
					item["email"] = email.String
				}
				if phone.Valid {
					item["phone"] = phone.String
				}
				if alarmLevels != nil && len(alarmLevels) > 0 {
					item["alarm_levels"] = alarmLevels
				}
				if alarmChannels != nil && len(alarmChannels) > 0 {
					item["alarm_channels"] = alarmChannels
				}
				if alarmScope.Valid {
					item["alarm_scope"] = alarmScope.String
				}
				if branchTag.Valid {
					item["branch_tag"] = branchTag.String
				}
				if lastLoginAt.Valid {
					item["last_login_at"] = lastLoginAt.Time.Format(time.RFC3339)
				}
				if tags != nil {
					item["tags"] = tags
				}
				if prefs != nil {
					item["preferences"] = prefs
				}
				writeJSON(w, http.StatusOK, Ok(item))
				return
			}
			writeJSON(w, http.StatusOK, Fail("database not available"))
			return
		default:
			w.WriteHeader(http.StatusMethodNotAllowed)
		}
		return
	}
	w.WriteHeader(http.StatusNotFound)
	// 注意：此函数已废弃，不再被路由注册使用
	// 新的实现请使用 UserHandler
}

