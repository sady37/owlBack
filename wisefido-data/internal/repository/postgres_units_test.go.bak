package repository

import (
	"context"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
)

func TestPostgresUnitsRepo_ListUnits(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("sqlmock.New: %v", err)
	}
	defer db.Close()

	repo := NewPostgresUnitsRepository(db)

	mock.ExpectQuery(`SELECT COUNT\(\*\) FROM units u WHERE`).
		WithArgs("tenant-1", "A", "1F").
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))

	mock.ExpectQuery(`SELECT\s+u.unit_id::text`).
		WithArgs("tenant-1", "A", "1F", 100, 0).
		WillReturnRows(sqlmock.NewRows([]string{
			"unit_id", "tenant_id", "branch_tag", "unit_name", "building", "floor", "area_tag", "unit_number", "layout_config",
			"unit_type", "is_public_space", "is_multi_person_room", "timezone",
		}).AddRow(
			"unit-1", "tenant-1", "DV1", "E101", "A", "1F", nil, "101", nil,
			"Facility", false, false, "America/Los_Angeles",
		))

	items, total, err := repo.ListUnits(context.Background(), "tenant-1", map[string]string{
		"building": "A",
		"floor":    "1F",
	}, 1, 100)
	if err != nil {
		t.Fatalf("ListUnits err: %v", err)
	}
	if total != 1 || len(items) != 1 {
		t.Fatalf("expected 1 item/total, got len=%d total=%d", len(items), total)
	}

	if err := mock.ExpectationsWereMet(); err != nil {
		t.Fatalf("expectations: %v", err)
	}
}
