package repository

import (
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/lib/pq"
	"go.uber.org/zap"
)

// PostgresDevicesRepo 设备Repository实现
// 遵循"bottom-up"设计原则，替代已删除的数据库触发器
type PostgresDevicesRepo struct {
	db     *sql.DB
	logger *zap.Logger
}

// NewPostgresDevicesRepo 创建设备Repository
func NewPostgresDevicesRepo(db *sql.DB) *PostgresDevicesRepo {
	return &PostgresDevicesRepo{db: db}
}

// SetLogger 设置日志记录器（可选，用于记录设备连接事件）
func (r *PostgresDevicesRepo) SetLogger(logger *zap.Logger) {
	r.logger = logger
}

// ListDevices 查询设备列表
// 功能：支持多种过滤条件和分页，自动过滤status='disabled'的设备
func (r *PostgresDevicesRepo) ListDevices(ctx context.Context, tenantID string, filters map[string]any) ([]Device, int, error) {
	if tenantID == "" {
		return []Device{}, 0, nil
	}

	where := []string{"d.tenant_id = $1", "d.status <> 'disabled'"}
	args := []any{tenantID}
	argN := 2

	// status IN (...)
	if v, ok := filters["status"]; ok {
		if arr, ok := v.([]string); ok && len(arr) > 0 {
			where = append(where, fmt.Sprintf("d.status = ANY($%d)", argN))
			args = append(args, pq.Array(arr))
			argN++
		}
	}
	if v, ok := filters["business_access"].(string); ok && v != "" {
		where = append(where, fmt.Sprintf("d.business_access = $%d", argN))
		args = append(args, v)
		argN++
	}
	if v, ok := filters["device_type"].(string); ok && v != "" {
		where = append(where, fmt.Sprintf("ds.device_type = $%d", argN))
		args = append(args, v)
		argN++
	}
	if v, ok := filters["search_type"].(string); ok && v != "" {
		kw, _ := filters["search_keyword"].(string)
		if kw != "" {
			col := "d.device_name"
			switch v {
			case "device_name":
				col = "d.device_name"
			case "serial_number":
				col = "d.serial_number"
			case "uid":
				col = "d.uid"
			}
			where = append(where, fmt.Sprintf("%s ILIKE $%d", col, argN))
			args = append(args, "%"+kw+"%")
			argN++
		}
	}

	queryCount := `
		SELECT COUNT(*)
		FROM devices d
		LEFT JOIN device_store ds ON d.device_store_id = ds.device_store_id
		WHERE ` + strings.Join(where, " AND ")
	var total int
	if err := r.db.QueryRowContext(ctx, queryCount, args...).Scan(&total); err != nil {
		return nil, 0, err
	}

	page, _ := filters["page"].(int)
	size, _ := filters["size"].(int)
	if page <= 0 {
		page = 1
	}
	if size <= 0 {
		size = 20
	}
	offset := (page - 1) * size

	argsList := append(args, size, offset)
	limitPos := argN
	offsetPos := argN + 1

	q := `
		SELECT
			d.device_id::text,
			d.tenant_id::text,
			CASE WHEN d.device_store_id IS NULL THEN NULL ELSE d.device_store_id::text END as device_store_id,
			d.device_name,
			ds.device_model,
			ds.device_type,
			d.serial_number,
			d.uid,
			ds.imei,
			ds.comm_mode,
			ds.firmware_version,
			ds.mcu_model,
			d.status,
			d.business_access,
			d.monitoring_enabled,
			COALESCE(r1.unit_id::text, r2.unit_id::text) as unit_id,
			CASE WHEN d.bound_room_id IS NULL THEN NULL ELSE d.bound_room_id::text END as bound_room_id,
			CASE WHEN d.bound_bed_id  IS NULL THEN NULL ELSE d.bound_bed_id::text  END as bound_bed_id,
			CASE WHEN d.metadata IS NULL THEN NULL ELSE d.metadata::text END as metadata
		FROM devices d
		LEFT JOIN device_store ds ON d.device_store_id = ds.device_store_id
		LEFT JOIN rooms r1 ON d.bound_room_id = r1.room_id
		LEFT JOIN beds  b  ON d.bound_bed_id  = b.bed_id
		LEFT JOIN rooms r2 ON b.room_id = r2.room_id
		WHERE ` + strings.Join(where, " AND ") + `
		ORDER BY d.device_name
		LIMIT $` + fmt.Sprintf("%d", limitPos) + ` OFFSET $` + fmt.Sprintf("%d", offsetPos)

	rows, err := r.db.QueryContext(ctx, q, argsList...)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	out := []Device{}
	for rows.Next() {
		var d Device
		if err := rows.Scan(
			&d.DeviceID,
			&d.TenantID,
			&d.DeviceStoreID,
			&d.DeviceName,
			&d.DeviceModel,
			&d.DeviceType,
			&d.SerialNumber,
			&d.UID,
			&d.IMEI,
			&d.CommMode,
			&d.FirmwareVersion,
			&d.MCUModel,
			&d.Status,
			&d.BusinessAccess,
			&d.MonitoringEnabled,
			&d.UnitID,
			&d.BoundRoomID,
			&d.BoundBedID,
			&d.Metadata,
		); err != nil {
			return nil, 0, err
		}
		out = append(out, d)
	}
	return out, total, rows.Err()
}

// GetDevice 查询单个设备
func (r *PostgresDevicesRepo) GetDevice(ctx context.Context, tenantID, deviceID string) (*Device, error) {
	q := `
		SELECT
			d.device_id::text,
			d.tenant_id::text,
			CASE WHEN d.device_store_id IS NULL THEN NULL ELSE d.device_store_id::text END as device_store_id,
			d.device_name,
			ds.device_model,
			ds.device_type,
			d.serial_number,
			d.uid,
			ds.imei,
			ds.comm_mode,
			ds.firmware_version,
			ds.mcu_model,
			d.status,
			d.business_access,
			d.monitoring_enabled,
			COALESCE(r1.unit_id::text, r2.unit_id::text) as unit_id,
			CASE WHEN d.bound_room_id IS NULL THEN NULL ELSE d.bound_room_id::text END as bound_room_id,
			CASE WHEN d.bound_bed_id  IS NULL THEN NULL ELSE d.bound_bed_id::text  END as bound_bed_id,
			CASE WHEN d.metadata IS NULL THEN NULL ELSE d.metadata::text END as metadata
		FROM devices d
		LEFT JOIN device_store ds ON d.device_store_id = ds.device_store_id
		LEFT JOIN rooms r1 ON d.bound_room_id = r1.room_id
		LEFT JOIN beds  b  ON d.bound_bed_id  = b.bed_id
		LEFT JOIN rooms r2 ON b.room_id = r2.room_id
		WHERE d.tenant_id = $1 AND d.device_id = $2
	`
	var d Device
	if err := r.db.QueryRowContext(ctx, q, tenantID, deviceID).Scan(
		&d.DeviceID,
		&d.TenantID,
		&d.DeviceStoreID,
		&d.DeviceName,
		&d.DeviceModel,
		&d.DeviceType,
		&d.SerialNumber,
		&d.UID,
		&d.IMEI,
		&d.CommMode,
		&d.FirmwareVersion,
		&d.MCUModel,
		&d.Status,
		&d.BusinessAccess,
		&d.MonitoringEnabled,
		&d.UnitID,
		&d.BoundRoomID,
		&d.BoundBedID,
		&d.Metadata,
	); err != nil {
		return nil, err
	}
	return &d, nil
}

// CreateDevice 手动创建设备与位置的绑定关系（出库操作）
// 替代触发器：trigger_validate_device_bed_tenant, trigger_validate_device_store_tenant
// 功能：系统管理员从device_store出库，创建设备与位置的绑定关系
// 用途：用于系统管理员手动出库操作
func (r *PostgresDevicesRepo) CreateDevice(ctx context.Context, tenantID string, payload map[string]any) (string, error) {
	if tenantID == "" {
		return "", fmt.Errorf("tenant_id is required")
	}

	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return "", err
	}
	defer tx.Rollback()

	// 1. 验证device_store_id
	deviceStoreID, ok := payload["device_store_id"].(string)
	if !ok || deviceStoreID == "" {
		return "", fmt.Errorf("device_store_id is required")
	}

	// 2. 查询device_store，验证是否存在且已分配给该tenant
	var dsTenantID sql.NullString
	var dsSerialNumber, dsUID sql.NullString
	err = tx.QueryRowContext(ctx, `
		SELECT tenant_id, serial_number, uid
		FROM device_store
		WHERE device_store_id = $1
	`, deviceStoreID).Scan(&dsTenantID, &dsSerialNumber, &dsUID)
	if err != nil {
		if err == sql.ErrNoRows {
			return "", fmt.Errorf("device_store not found: device_store_id=%s", deviceStoreID)
		}
		return "", fmt.Errorf("failed to query device_store: %w", err)
	}

	// 验证租户一致性
	unallocatedTenantID := "00000000-0000-0000-0000-000000000000"
	if !dsTenantID.Valid || dsTenantID.String == unallocatedTenantID {
		return "", fmt.Errorf("device_store not allocated to tenant: device_store_id=%s (device must be allocated before checkout)", deviceStoreID)
	}
	if dsTenantID.String != tenantID {
		return "", fmt.Errorf("device_store belongs to different tenant: device_store_id=%s (expected %s, got %s)", deviceStoreID, tenantID, dsTenantID.String)
	}

	// 3. 验证serial_number和uid至少填一个（从device_store获取）
	if !dsSerialNumber.Valid && !dsUID.Valid {
		return "", fmt.Errorf("device_store has no serial_number or uid: device_store_id=%s", deviceStoreID)
	}

	// 4. 验证位置绑定（如果提供）
	boundRoomID, hasRoomID := payload["bound_room_id"].(string)
	boundBedID, hasBedID := payload["bound_bed_id"].(string)

	// 验证bound_room_id（如果提供）
	if hasRoomID && boundRoomID != "" {
		var unitTenantID sql.NullString
		err := tx.QueryRowContext(ctx, `
			SELECT u.tenant_id
			FROM rooms r
			JOIN units u ON r.unit_id = u.unit_id
			WHERE r.room_id = $1
		`, boundRoomID).Scan(&unitTenantID)
		if err != nil {
			if err == sql.ErrNoRows {
				return "", fmt.Errorf("room not found: room_id=%s (room must belong to an existing unit)", boundRoomID)
			}
			return "", fmt.Errorf("failed to validate room: %w", err)
		}
		if !unitTenantID.Valid || unitTenantID.String != tenantID {
			return "", fmt.Errorf("room belongs to different tenant: room_id=%s (expected %s, got %s)", boundRoomID, tenantID, unitTenantID.String)
		}
	}

	// 验证bound_bed_id（如果提供）
	if hasBedID && boundBedID != "" {
		var unitTenantID sql.NullString
		err := tx.QueryRowContext(ctx, `
			SELECT u.tenant_id
			FROM beds b
			JOIN rooms r ON b.room_id = r.room_id
			JOIN units u ON r.unit_id = u.unit_id
			WHERE b.bed_id = $1
		`, boundBedID).Scan(&unitTenantID)
		if err != nil {
			if err == sql.ErrNoRows {
				return "", fmt.Errorf("bed not found: bed_id=%s (bed must belong to an existing room)", boundBedID)
			}
			return "", fmt.Errorf("failed to validate bed: %w", err)
		}
		if !unitTenantID.Valid || unitTenantID.String != tenantID {
			return "", fmt.Errorf("bed belongs to different tenant: bed_id=%s (expected %s, got %s)", boundBedID, tenantID, unitTenantID.String)
		}
	}

	// 验证不能同时绑定到room和bed
	if (hasRoomID && boundRoomID != "") && (hasBedID && boundBedID != "") {
		return "", fmt.Errorf("cannot bind to both room and bed: bound_room_id=%s, bound_bed_id=%s (mutually exclusive)", boundRoomID, boundBedID)
	}

	// 5. 生成device_name（如果未提供，从device_store生成）
	deviceName, _ := payload["device_name"].(string)
	if deviceName == "" {
		// 从device_store生成默认名称
		if dsSerialNumber.Valid && dsSerialNumber.String != "" {
			deviceName = dsSerialNumber.String
		} else if dsUID.Valid && dsUID.String != "" {
			deviceName = dsUID.String
		} else {
			deviceName = "Device-" + deviceStoreID[:8]
		}
	}

	// 6. 插入devices记录
	insertQuery := `
		INSERT INTO devices (
			tenant_id, device_store_id, device_name,
			serial_number, uid,
			bound_room_id, bound_bed_id,
			status, business_access, monitoring_enabled
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
		RETURNING device_id::text
	`

	var deviceID string
	var boundRoomIDVal, boundBedIDVal interface{}
	if hasRoomID && boundRoomID != "" {
		boundRoomIDVal = boundRoomID
	} else {
		boundRoomIDVal = nil
	}
	if hasBedID && boundBedID != "" {
		boundBedIDVal = boundBedID
	} else {
		boundBedIDVal = nil
	}

	err = tx.QueryRowContext(ctx, insertQuery,
		tenantID,
		deviceStoreID,
		deviceName,
		dsSerialNumber,
		dsUID,
		boundRoomIDVal,
		boundBedIDVal,
		"offline",        // status默认值
		"pending",        // business_access默认值（等待租户审批）
		false,            // monitoring_enabled默认值
	).Scan(&deviceID)
	if err != nil {
		return "", fmt.Errorf("failed to create device: %w", err)
	}

	if err := tx.Commit(); err != nil {
		return "", err
	}

	return deviceID, nil
}

// UpdateDevice 更新设备信息
// 替代触发器: trigger_validate_device_bed_tenant, trigger_validate_device_store_tenant
// 功能：更新设备信息，验证bound_room_id、bound_bed_id、device_store_id的租户一致性
func (r *PostgresDevicesRepo) UpdateDevice(ctx context.Context, tenantID, deviceID string, payload map[string]any) error {
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		_ = tx.Rollback()
	}()

	// 1. 验证bound_room_id（如果更新）- 替代trigger_validate_device_bed_tenant
	// 通过unit层级验证：验证room.unit_id对应的unit.tenant_id = device.tenant_id
	// 原因：room.tenant_id已经通过trigger_validate_room_tenant保证等于unit.tenant_id
	if v, ok := payload["bound_room_id"]; ok {
		if roomID, ok := v.(string); ok && roomID != "" {
			var unitTenantID string
			if err := tx.QueryRowContext(ctx,
				"SELECT u.tenant_id::text FROM rooms r JOIN units u ON r.unit_id = u.unit_id WHERE r.room_id = $1",
				roomID,
			).Scan(&unitTenantID); err != nil {
				if err == sql.ErrNoRows {
					return fmt.Errorf("room not found: room_id=%s", roomID)
				}
				return fmt.Errorf("failed to validate bound_room_id: %w", err)
			}
			if unitTenantID != tenantID {
				return fmt.Errorf("room not found: room_id=%s (room's unit belongs to tenant %s, expected %s)", roomID, unitTenantID, tenantID)
			}
		}
	}

	// 2. 验证bound_bed_id（如果更新）- 替代trigger_validate_device_bed_tenant
	// 通过unit层级验证：验证bed.room_id对应的room.unit_id对应的unit.tenant_id = device.tenant_id
	// 原因：bed.tenant_id已经通过trigger_validate_bed_tenant保证等于room.tenant_id，room.tenant_id已经通过trigger_validate_room_tenant保证等于unit.tenant_id
	if v, ok := payload["bound_bed_id"]; ok {
		if bedID, ok := v.(string); ok && bedID != "" {
			var unitTenantID string
			if err := tx.QueryRowContext(ctx,
				"SELECT u.tenant_id::text FROM beds b JOIN rooms r ON b.room_id = r.room_id JOIN units u ON r.unit_id = u.unit_id WHERE b.bed_id = $1",
				bedID,
			).Scan(&unitTenantID); err != nil {
				if err == sql.ErrNoRows {
					return fmt.Errorf("bed not found: bed_id=%s", bedID)
				}
				return fmt.Errorf("failed to validate bound_bed_id: %w", err)
			}
			if unitTenantID != tenantID {
				return fmt.Errorf("bed not found: bed_id=%s (bed's room's unit belongs to tenant %s, expected %s)", bedID, unitTenantID, tenantID)
			}
		}
	}

	// 3. 验证device_store_id的租户一致性（如果更新）- 替代trigger_validate_device_store_tenant
	if v, ok := payload["device_store_id"]; ok {
		if deviceStoreID, ok := v.(string); ok && deviceStoreID != "" {
			var dsTenantID sql.NullString
			if err := tx.QueryRowContext(ctx,
				"SELECT tenant_id FROM device_store WHERE device_store_id = $1",
				deviceStoreID,
			).Scan(&dsTenantID); err != nil {
				if err == sql.ErrNoRows {
					return fmt.Errorf("device_store not found: device_store_id=%s", deviceStoreID)
				}
				return fmt.Errorf("failed to validate device_store_id: %w", err)
			}
			// 如果device_store已分配给租户，验证租户一致性
			unallocatedTenantID := "00000000-0000-0000-0000-000000000000"
			if dsTenantID.Valid && dsTenantID.String != unallocatedTenantID && dsTenantID.String != tenantID {
				return fmt.Errorf("device_store_id %s is assigned to a different tenant (expected %s, got %s)", deviceStoreID, tenantID, dsTenantID.String)
			}
		}
	}

	// 4. 执行UPDATE
	set := []string{}
	args := []any{tenantID, deviceID}
	argN := 3
	add := func(col string, v any) {
		set = append(set, fmt.Sprintf("%s = $%d", col, argN))
		args = append(args, v)
		argN++
	}
	if v, ok := payload["device_name"]; ok {
		add("device_name", v)
	}
	if v, ok := payload["business_access"]; ok {
		add("business_access", v)
	}
	if v, ok := payload["status"]; ok {
		add("status", v)
	}
	if v, ok := payload["monitoring_enabled"]; ok {
		add("monitoring_enabled", v)
	}
	if v, ok := payload["bound_room_id"]; ok {
		add("bound_room_id", v)
	}
	if v, ok := payload["bound_bed_id"]; ok {
		add("bound_bed_id", v)
	}
	if v, ok := payload["device_store_id"]; ok {
		add("device_store_id", v)
	}

	if len(set) == 0 {
		return nil
	}
	q := "UPDATE devices SET " + strings.Join(set, ", ") + " WHERE tenant_id = $1 AND device_id = $2"
	if _, err := tx.ExecContext(ctx, q, args...); err != nil {
		return err
	}
	return tx.Commit()
}

// DeleteDevice 删除设备与位置的绑定关系（设备退回）
// 替代触发器：无（这是基础操作）
// 功能：删除设备与位置的绑定关系（设备退回库存或删除关系记录）
// 验证：检查设备是否已使用（is_device_used()），如果已使用，只能软删除（DisableDevice）
func (r *PostgresDevicesRepo) DeleteDevice(ctx context.Context, tenantID, deviceID string) error {
	// 1. 检查设备是否存在
	var deviceExists bool
	err := r.db.QueryRowContext(ctx, `
		SELECT EXISTS(SELECT 1 FROM devices WHERE tenant_id = $1 AND device_id = $2)
	`, tenantID, deviceID).Scan(&deviceExists)
	if err != nil {
		return fmt.Errorf("failed to check device: %w", err)
	}
	if !deviceExists {
		return fmt.Errorf("device not found: tenant_id=%s, device_id=%s", tenantID, deviceID)
	}

	// 2. 检查设备是否已使用（调用is_device_used()函数）
	var isUsed bool
	err = r.db.QueryRowContext(ctx, `SELECT is_device_used($1)`, deviceID).Scan(&isUsed)
	if err != nil {
		return fmt.Errorf("failed to check if device is used: %w", err)
	}

	if isUsed {
		// 设备已使用，不能物理删除，只能软删除
		return fmt.Errorf("cannot delete device: device has reported data (use DisableDevice for soft delete): device_id=%s", deviceID)
	}

	// 3. 物理删除设备记录（设备退回库存）
	_, err = r.db.ExecContext(ctx, `
		DELETE FROM devices
		WHERE tenant_id = $1 AND device_id = $2
	`, tenantID, deviceID)
	if err != nil {
		return fmt.Errorf("failed to delete device: %w", err)
	}

	return nil
}

// DisableDevice 软删除设备
// 功能：设置status='disabled', business_access='rejected', monitoring_enabled=FALSE
func (r *PostgresDevicesRepo) DisableDevice(ctx context.Context, tenantID, deviceID string) error {
	_, err := r.db.ExecContext(ctx, `
		UPDATE devices
		SET status='disabled', business_access='rejected', monitoring_enabled=FALSE
		WHERE tenant_id=$1 AND device_id=$2
	`, tenantID, deviceID)
	return err
}

// GetOrCreateDeviceFromStore 首次连接时自动创建设备记录
// 替代触发器: trigger_validate_device_identifier, trigger_validate_device_store_tenant
// 功能：从device_store自动创建设备记录，验证serial_number/uid和device_store租户一致性
// 用途：用于设备首次MQTT连接时的自动创建
func (r *PostgresDevicesRepo) GetOrCreateDeviceFromStore(ctx context.Context, identifier string, mqttTopic string) (*Device, error) {
	// Helper function to log messages (if logger is available)
	logInfo := func(msg string, fields ...zap.Field) {
		if r.logger != nil {
			r.logger.Info(msg, fields...)
		}
	}
	logWarn := func(msg string, fields ...zap.Field) {
		if r.logger != nil {
			r.logger.Warn(msg, fields...)
		}
	}

	// 1. First, try to get device from devices table by serial_number or uid
	deviceQuery := `
		SELECT
			d.device_id::text,
			d.tenant_id::text,
			CASE WHEN d.device_store_id IS NULL THEN NULL ELSE d.device_store_id::text END as device_store_id,
			d.device_name,
			ds.device_model,
			ds.device_type,
			d.serial_number,
			d.uid,
			ds.imei,
			ds.comm_mode,
			ds.firmware_version,
			ds.mcu_model,
			d.status,
			d.business_access,
			d.monitoring_enabled,
			NULL as unit_id,
			CASE WHEN d.bound_room_id IS NULL THEN NULL ELSE d.bound_room_id::text END as bound_room_id,
			CASE WHEN d.bound_bed_id  IS NULL THEN NULL ELSE d.bound_bed_id::text  END as bound_bed_id,
			CASE WHEN d.metadata IS NULL THEN NULL ELSE d.metadata::text END as metadata
		FROM devices d
		LEFT JOIN device_store ds ON d.device_store_id = ds.device_store_id
		WHERE (d.serial_number = $1 OR d.uid = $1)
		LIMIT 1
	`

	var d Device
	err := r.db.QueryRowContext(ctx, deviceQuery, identifier).Scan(
		&d.DeviceID,
		&d.TenantID,
		&d.DeviceStoreID,
		&d.DeviceName,
		&d.DeviceModel,
		&d.DeviceType,
		&d.SerialNumber,
		&d.UID,
		&d.IMEI,
		&d.CommMode,
		&d.FirmwareVersion,
		&d.MCUModel,
		&d.Status,
		&d.BusinessAccess,
		&d.MonitoringEnabled,
		&d.UnitID,
		&d.BoundRoomID,
		&d.BoundBedID,
		&d.Metadata,
	)

	if err == nil {
		// Device found in devices table, return it
		return &d, nil
	}

	if err != sql.ErrNoRows {
		// Unexpected database error
		return nil, fmt.Errorf("failed to query device: %w", err)
	}

	// 2. Device not found in devices table, check device_store table
	unallocatedTenantID := "00000000-0000-0000-0000-000000000000"
	deviceStoreQuery := `
		SELECT
			device_store_id::text,
			device_type,
			device_model,
			serial_number,
			uid,
			imei,
			comm_mode,
			mcu_model,
			firmware_version,
			tenant_id::text,
			allow_access
		FROM device_store
		WHERE (serial_number = $1 OR uid = $1)
		LIMIT 1
	`

	var dsDeviceStoreID, dsDeviceType, dsTenantID string
	var dsDeviceModel, dsSerialNumber, dsUID, dsIMEI, dsCommMode, dsMCUModel, dsFirmwareVersion sql.NullString
	var dsAllowAccess bool

	err = r.db.QueryRowContext(ctx, deviceStoreQuery, identifier).Scan(
		&dsDeviceStoreID,
		&dsDeviceType,
		&dsDeviceModel,
		&dsSerialNumber,
		&dsUID,
		&dsIMEI,
		&dsCommMode,
		&dsMCUModel,
		&dsFirmwareVersion,
		&dsTenantID,
		&dsAllowAccess,
	)

	if err == sql.ErrNoRows {
		// Case 3: Device not registered in device_store
		logWarn("Unauthorized device connection attempt",
			zap.String("identifier", identifier),
			zap.String("mqtt_topic", mqttTopic),
			zap.String("reason", "device_not_registered"),
			zap.String("action", "connection_rejected"),
			zap.String("security_level", "warning"),
		)
		return nil, fmt.Errorf("unauthorized device: not registered in device_store")
	}

	if err != nil {
		// Unexpected database error
		logWarn("Device connection failed: database error",
			zap.String("identifier", identifier),
			zap.String("mqtt_topic", mqttTopic),
			zap.String("reason", "database_error"),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to query device_store: %w", err)
	}

	// 3. Check if device is allocated to a tenant
	if dsTenantID == unallocatedTenantID {
		// Case 2: Device registered but not allocated
		serialNum := ""
		if dsSerialNumber.Valid {
			serialNum = dsSerialNumber.String
		}
		uid := ""
		if dsUID.Valid {
			uid = dsUID.String
		}
		logWarn("Device connection rejected: not allocated",
			zap.String("device_store_id", dsDeviceStoreID),
			zap.String("serial_number", serialNum),
			zap.String("uid", uid),
			zap.String("reason", "device_not_allocated"),
			zap.String("action", "connection_rejected"),
		)
		return nil, fmt.Errorf("device not allocated to tenant")
	}

	// 4. 验证serial_number和uid至少填一个 - 替代trigger_validate_device_identifier
	if (!dsSerialNumber.Valid || dsSerialNumber.String == "") && (!dsUID.Valid || dsUID.String == "") {
		logWarn("Device connection rejected: missing identifier",
			zap.String("device_store_id", dsDeviceStoreID),
			zap.String("identifier", identifier),
			zap.String("mqtt_topic", mqttTopic),
			zap.String("reason", "missing_serial_number_and_uid"),
			zap.String("action", "connection_rejected"),
		)
		return nil, fmt.Errorf("device must have at least one identifier: serial_number or uid")
	}

	// 5. Case 1: Device is registered and allocated, create devices record
	tx, err := r.db.BeginTx(ctx, nil)
	if err != nil {
		logWarn("Device connection failed: transaction error",
			zap.String("device_store_id", dsDeviceStoreID),
			zap.String("identifier", identifier),
			zap.String("mqtt_topic", mqttTopic),
			zap.String("reason", "transaction_error"),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer func() {
		if err != nil {
			_ = tx.Rollback()
		}
	}()

	// Generate device name from device_type and serial_number/uid
	deviceName := dsDeviceType
	if dsSerialNumber.Valid && dsSerialNumber.String != "" {
		deviceName = dsDeviceType + "-" + dsSerialNumber.String
	} else if dsUID.Valid && dsUID.String != "" {
		deviceName = dsDeviceType + "-" + dsUID.String
	}

	// Insert device record
	insertQuery := `
		INSERT INTO devices (
			tenant_id,
			device_store_id,
			device_name,
			serial_number,
			uid,
			status,
			business_access,
			monitoring_enabled
		) VALUES ($1, $2, $3, $4, $5, 'online', 'pending', FALSE)
		RETURNING device_id::text
	`

	var newDeviceID string
	err = tx.QueryRowContext(ctx, insertQuery,
		dsTenantID,
		dsDeviceStoreID,
		deviceName,
		dsSerialNumber,
		dsUID,
	).Scan(&newDeviceID)

	if err != nil {
		logWarn("Device connection failed: failed to create device record",
			zap.String("device_store_id", dsDeviceStoreID),
			zap.String("tenant_id", dsTenantID),
			zap.String("identifier", identifier),
			zap.String("mqtt_topic", mqttTopic),
			zap.String("reason", "device_creation_failed"),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to create device record: %w", err)
	}

	if err = tx.Commit(); err != nil {
		logWarn("Device connection failed: transaction commit error",
			zap.String("device_store_id", dsDeviceStoreID),
			zap.String("device_id", newDeviceID),
			zap.String("tenant_id", dsTenantID),
			zap.String("identifier", identifier),
			zap.String("mqtt_topic", mqttTopic),
			zap.String("reason", "transaction_commit_failed"),
			zap.Error(err),
		)
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	// Log successful auto-creation
	serialNum := ""
	if dsSerialNumber.Valid {
		serialNum = dsSerialNumber.String
	}
	uid := ""
	if dsUID.Valid {
		uid = dsUID.String
	}
	logInfo("Device auto-created from device_store",
		zap.String("device_store_id", dsDeviceStoreID),
		zap.String("device_id", newDeviceID),
		zap.String("tenant_id", dsTenantID),
		zap.String("serial_number", serialNum),
		zap.String("uid", uid),
		zap.String("device_type", dsDeviceType),
		zap.String("source", "mqtt_first_connection"),
		zap.String("mqtt_topic", mqttTopic),
	)

	// Query and return the newly created device
	return r.GetDevice(ctx, dsTenantID, newDeviceID)
}

